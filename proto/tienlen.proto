syntax = "proto3";

package tienlen.v1;

option go_package = "tienlen/proto;pb";

// --- Enums ---

enum Suit {
  SUIT_SPADES = 0;
  SUIT_CLUBS = 1;
  SUIT_DIAMONDS = 2;
  SUIT_HEARTS = 3;
}

enum Rank {
  RANK_THREE = 0;
  RANK_FOUR = 1;
  RANK_FIVE = 2;
  RANK_SIX = 3;
  RANK_SEVEN = 4;
  RANK_EIGHT = 5;
  RANK_NINE = 6;
  RANK_TEN = 7;
  RANK_JACK = 8;
  RANK_QUEEN = 9;
  RANK_KING = 10;
  RANK_ACE = 11;
  RANK_TWO = 12;
}

enum GamePhase {
  PHASE_WAITING = 0;
  PHASE_PLAYING = 1;
  PHASE_FINISHED = 2;
}

enum OpCode {
  OP_CODE_UNSPECIFIED = 0;
  OP_CODE_START_GAME = 1;
  OP_CODE_PLAY_CARDS = 2;
  OP_CODE_PASS_TURN = 3;
  OP_CODE_REQUEST_NEW_GAME = 4;

  OP_CODE_PLAYER_JOINED = 50;
  OP_CODE_PLAYER_LEFT = 51;

  OP_CODE_GAME_STARTED = 100;
  OP_CODE_CARD_PLAYED = 102;
  OP_CODE_TURN_PASSED = 103;
  OP_CODE_GAME_ENDED = 104;
  OP_CODE_GAME_ERROR = 105;
  OP_CODE_PIG_CHOPPED = 106;
  OP_CODE_PLAYER_FINISHED = 107;
  OP_CODE_IN_GAME_CHAT = 108;
}

// --- Basic Structures ---

message MatchLabel {
  int32 open = 1 [json_name = "open"];
  string state = 2 [json_name = "state"];
}

message Card {
  Suit suit = 1;
  Rank rank = 2;
}

message PlayerState {
    string user_id = 1;
    int32 seat = 2;
    bool is_owner = 3;
    int32 cards_remaining = 4; // Public info
    string display_name = 5;
    int32 avatar_index = 6;
}

// --- Client -> Server Requests ---

message FindMatchRequest {}

message StartGameRequest {}

message FindMatchResponse {
  string match_id = 1;
}

message PlayCardsRequest {
  repeated Card cards = 1;
}

message PassTurnRequest {}

message RequestNewGameRequest {}

message InGameChatRequest {
  string message = 1;
}

// --- Server -> Client Events ---

message PlayerJoinedEvent {
  PlayerState player = 1;
}

message PlayerLeftEvent {
  int32 seat = 1; // 0-based index
  string user_id = 2;
}

// Snapshot of lobby state broadcast after a player joins.
message MatchStateSnapshot {
  repeated string seats = 1;
  int32 owner_seat = 2; // 0-based index
  int64 tick = 3;
  repeated PlayerState players = 4; // Full player details
  int64 turn_seconds_remaining = 5; // Seconds remaining before the current turn expires
}

message GameStartedEvent {
  int32 first_turn_seat = 1; // 0-based index
  GamePhase phase = 2;
  repeated Card hand = 3;
  int64 turn_seconds_remaining = 4; // Seconds remaining before the current turn expires
}

message CardPlayedEvent {
  int32 seat = 1; // 0-based index
  repeated Card cards = 2;
  int32 next_turn_seat = 3; // 0-based index
  bool new_round = 4; // True if this clears the board
  int64 turn_seconds_remaining = 5; // Seconds remaining before the next turn expires
}

message TurnPassedEvent {
  int32 seat = 1; // 0-based index
  int32 next_turn_seat = 2; // 0-based index
  bool new_round = 3; // True if this pass results in a round reset
  int64 turn_seconds_remaining = 4; // Seconds remaining before the next turn expires
}

message CardList {
  repeated Card cards = 1;
}

message GameEndedEvent {
  repeated int32 finish_order_seats = 1; // 0-based seat indices in rank order
  map<string, int64> balance_changes = 2; // UserID -> Gold (+/-)
  map<int32, CardList> remaining_hands = 3; // Seat Index -> Cards
}

message PlayerFinishedEvent {
  int32 seat = 1; // 0-based index
  int32 rank = 2; // 1 = 1st, 2 = 2nd, etc.
}

message GameErrorEvent {
    int32 code = 1;
    string message = 2;
}

message PigChoppedEvent {
  int32 source_seat = 1; // 0-based index
  int32 target_seat = 2; // 0-based index
  string chop_type = 3;  // "3-Pine", "Quad", "4-Pine", "5-Pine", "Black Pig", "Red Pig"
  repeated Card cards_chopped = 4;
  repeated Card cards_chopping = 5;
  map<string, int64> balance_changes = 6; // UserID -> Gold (+/-)
}

message InGameChatEvent {
  int32 seat_index = 1; // 0-based index
  string message = 2;
}
