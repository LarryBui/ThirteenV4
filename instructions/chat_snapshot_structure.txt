Proposed scene/DI restructuring for clearer flow and separation:

Scene roles: Keep Home lean for auth/UX and GameRoom for match play. Extract a tiny Bootstrap additive scene as the true entry point to own: config load, logging, service container initialization, cross-scene singletons (network client, player/session state, config, audio bus, analytics). Load Home additively after bootstrap.
Scene loading pattern: Use additive loads for Home → GameRoom, unloading the previous scene’s presentation while keeping the bootstrap scene resident so shared services persist. Centralize scene transitions in a SceneNavigator service (no UI code calling SceneManager directly).
Auth + matchmaking flow: In Home, UI triggers an AuthController that depends only on an IAuthService (handles token/session refresh) and IMatchmakingService (handles join/create). When Play is clicked: disable UI, call matchmaking, on success instruct SceneNavigator to load GameRoom additively; on failure re-enable UI with error. Carry the match context via a MatchSession model stored in the bootstrap scope.
GameRoom responsibilities: View-only components talk to a thin GameRoomController that takes IMatchService/IMatchState interfaces. Start Game triggers a command on IMatchService (idempotent). Keep rendering/input separate from network logic; add a MatchStatePresenter that subscribes to match state updates to drive UI.
DI boundaries: Define interfaces in a shared assembly (e.g., TienLen.Application), concrete implementations in infrastructure assemblies (e.g., Nakama clients). Register in bootstrap: IAuthService, IMatchmakingService, IMatchService, IMatchState, ILogger, IConfig, IScheduler/ITimer, IAudioBus, IAnalytics. Provide factories for scene-scoped controllers (HomeController, GameRoomController) so they resolve dependencies cleanly per scene.
State management: Maintain a PlayerSession (auth tokens, user id) and MatchSession (match id, slots, rules, reconnection data) as services with clear lifetimes: bootstrap-resident, reset on logout/leave match. Ensure reconnection flow can rehydrate GameRoom without a full app restart.
Networking: Keep Nakama client lifetime in bootstrap. Expose only domain-facing interfaces to scenes. Use message handlers to push updates into IMatchState; presenters subscribe to that, not directly to sockets.
Loading/error UX: Standardize loading overlays and error surfaces per scene; avoid duplicated spinners/toasts. SceneNavigator can show a global loading screen during transitions.
Testing hooks: With DI, controllers and services become unit-testable (auth flow, matchmaking join, start-game command idempotency). No code changes yet; once ready, we can add tests to lock behavior.
If you want, I can draft a concrete scene/DI layout (bootstrap scene content, service registrations, and per-scene controller wiring) before touching code.